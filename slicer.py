from cvxpy import * #as cvx
import numpy
from numpy import matlib


class Queue(object):

	def __init__(self, queueId, path, link):
		'''
		Input: queueId [integer], path [object of class Path], link [object of class Link]
		'''
		self.id = queueId
		self.path = path
		self.link = link
		self.minRate = 0
		self.maxRate = 0

	def __repr__(self):
		return "Queue %d" %(self.id)

	def setMinRate(self, rate):
		'''
		Input: rate [integer]
		Function: sets the minimum rate of the queue 
		'''
		self.minRate = rate

	def setMaxRate(self, rate):
		'''
		Input: rate [integer]
		Function: sets the maximum rate of the queue 
		'''
		self.maxRate = rate


class Link(object):

	def __init__(self, linkId, sw1, p1, sw2, p2, capacity):
		'''
		Input: linkId [integer], sw1 [integer], p1 [integer], sw2 [integer], p2 [integer], capacity [integer]
		'''
		self.id = linkId
		self.capacity = capacity
		self.sw1 = sw1
		self.sw2 = sw2
		self.port1 = p1
		self.port2 = p2
		self.QoS =  [] 

	def __repr__(self):
		return "Link %d" %(self.id)

	def addQueueToLink(self, path):
		'''
		Input: path [object of class Path]
		Function: add a queue to the QoS queues of the link, specifying to which path the queue belongs 
		'''
		self.QoS.append(Queue(len(self.QoS) + 1, path, self))

	def remQueueFromLink(self, index):
		'''
		Input: index [integer]
		Function: remove the queue whose index in the 'QoS' list is equal to 'index' from the link 
		'''
		self.QoS.pop(index)

	def getQueueIndexByPath(self, path):
		'''
		Input: path [object of class Path]
		Function: find the index in the 'QoS' list of the queue belonging to the path 'path'
		'''
		for qdx, q in enumerate(self.QoS):
			if q.path == path:
				return qdx

class Path(object):

	def __init__(self, pathId, links, demand):
		'''
		Input: pathId [integer], links [list of objects of class Link], demand [object of class Demand]
		'''
		self.id = pathId
		self.bandwidth = 0
		self.demand = demand
		self.links = []
		for link in links:
			self.links.append(self.addLinkToPath(link, demand.net))

	def __repr__(self):
		return "Path %d" %(self.id)

	def __del__(self):
		for l in self.links:
			self.remLinkFromPath(l)

	def addLinkToPath(self, link, net):
		'''
		Input: link [object of class Link], net [object of class Network]
		Function: add the link 'link' to the path by creating a new queue 
		'''
		link.addQueueToLink(self)
		return link

	def remLinkFromPath(self, link):
		'''
		Input: link [object of class Link]
		Function: remove the link 'link' from the path by deleting the corresponding queue 
		'''
		queueIndex = link.getQueueIndexByPath(self)
		link.remQueueFromLink(queueIndex)

	def getLinkById(self, linkId, net):
		'''
		Input: linkId [integer], net [object of class Network]
		Output: l [object of class Link]
		Function: obtains the link by its id 'linkId'
		'''
		for l in net.links:
			if l.id == linkId:
				return l

	def getQueuesByPath(self):
		'''
		Output: queues [list of objects of class Queue]
		Function: obtains all the queues belonging to the path
		'''
		queues = []
		for l in self.links:
			for q in l.QoS:
				if q.path == self:
					queues.append(q)
		return queues


class Demand(object):

	def __init__(self, demandId, trafficClass, trafficEstim, src, dst, paths, net):
		'''
		Input: demandId [integer], trafficClass [integer], trafficEstim [integer], src [integer], dst [integer], paths [list of objects of class Path], net [object of class Network]
		'''
		self.id = demandId#
		self.trafficClass = trafficClass
		self.src = src
		self.dst = dst
		self.net = net
		self.trafficEstim = trafficEstim
		self.bandwidth = 0
		self.paths = []
		for pdx, p in enumerate(paths):
			self.paths.append(Path(pdx+1, p, self))

	def __repr__(self):
		return "Demand %d" %(self.id)

	def addPath(self, links, net):
		'''
		Input: links [list of objects of class Link], net [object of class Network]
		Function: creates and add a new path to the demand
		'''
		self.paths.append(Path(len(self.paths)+1, links, self))

	def delPath(self):
		'''
		Not yet implemented
		'''
		pass


class Network(object):

	def __init__(self, matrix, linkMatrix=None):
		'''
		Input: matrix [list of lists of integers], linkMatrix [list of lists of lists of 2 integers]
		'''
		self.adjMatrix = matrix
		self.linkMatrix = linkMatrix
		self.links = []
		self.portCounters = [0]*len(self.adjMatrix)
		self.linkCounter = 0
		if self.linkMatrix == None:
			#use port numbers generated by the method
			for idx, i in enumerate(self.adjMatrix):
				for jdx, j in enumerate(i):
					if j > 0:
						self.linkCounter += 1
						self.portCounters[idx] += 1
						self.portCounters[jdx] += 1
						self.links.append(Link(self.linkCounter, idx+1, self.portCounters[idx], jdx+1, self.portCounters[jdx], j))
		else:
			#use port numbers given as inputs by the user
			for idx, i in enumerate(self.adjMatrix):
				for jdx, j in enumerate(i):
					if j > 0:
						self.linkCounter += 1
						port1 = self.linkMatrix[idx][jdx][0]
						port2 = self.linkMatrix[idx][jdx][1]
						self.links.append(Link(self.linkCounter, idx+1, port1, jdx+1, port2, j))			

	def findLinkBySwitches(self, sw1, sw2):
		'''
		Input: sw1 [integer], sw2 [integer]
		Output: l [object of class Link]
		Function: returns the link connecting the two switches given as inputs
		'''
		for l in self.links:
			if l.sw1 == sw1 and l.sw2 == sw2:
				return l
		return "Not Found"

	def showNetworkQoS(self):
		'''
		Function: shows the QoS setting for each queue of the network
		'''
		for l in self.links:
			for q in l.QoS:
				print l, q
				print float(q.minRate), float(q.maxRate)



